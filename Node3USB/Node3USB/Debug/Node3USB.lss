
Node3USB.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000001ba  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .comment      00000030  00000000  00000000  0000020e  2**0
                  CONTENTS, READONLY
  2 .debug_aranges 00000050  00000000  00000000  0000023e  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   00000168  00000000  00000000  0000028e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 000000f5  00000000  00000000  000003f6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   00000776  00000000  00000000  000004eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_frame  00000068  00000000  00000000  00000c64  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    000084b7  00000000  00000000  00000ccc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_ranges 00000030  00000000  00000000  00009183  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_macro  0000346b  00000000  00000000  000091b3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	4b c0       	rjmp	.+150    	; 0x98 <__ctors_end>
   2:	00 00       	nop
   4:	66 c0       	rjmp	.+204    	; 0xd2 <__bad_interrupt>
   6:	00 00       	nop
   8:	64 c0       	rjmp	.+200    	; 0xd2 <__bad_interrupt>
   a:	00 00       	nop
   c:	62 c0       	rjmp	.+196    	; 0xd2 <__bad_interrupt>
   e:	00 00       	nop
  10:	60 c0       	rjmp	.+192    	; 0xd2 <__bad_interrupt>
  12:	00 00       	nop
  14:	5e c0       	rjmp	.+188    	; 0xd2 <__bad_interrupt>
  16:	00 00       	nop
  18:	5c c0       	rjmp	.+184    	; 0xd2 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	5a c0       	rjmp	.+180    	; 0xd2 <__bad_interrupt>
  1e:	00 00       	nop
  20:	58 c0       	rjmp	.+176    	; 0xd2 <__bad_interrupt>
  22:	00 00       	nop
  24:	56 c0       	rjmp	.+172    	; 0xd2 <__bad_interrupt>
  26:	00 00       	nop
  28:	54 c0       	rjmp	.+168    	; 0xd2 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	52 c0       	rjmp	.+164    	; 0xd2 <__bad_interrupt>
  2e:	00 00       	nop
  30:	50 c0       	rjmp	.+160    	; 0xd2 <__bad_interrupt>
  32:	00 00       	nop
  34:	4e c0       	rjmp	.+156    	; 0xd2 <__bad_interrupt>
  36:	00 00       	nop
  38:	4c c0       	rjmp	.+152    	; 0xd2 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	4a c0       	rjmp	.+148    	; 0xd2 <__bad_interrupt>
  3e:	00 00       	nop
  40:	48 c0       	rjmp	.+144    	; 0xd2 <__bad_interrupt>
  42:	00 00       	nop
  44:	46 c0       	rjmp	.+140    	; 0xd2 <__bad_interrupt>
  46:	00 00       	nop
  48:	44 c0       	rjmp	.+136    	; 0xd2 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	42 c0       	rjmp	.+132    	; 0xd2 <__bad_interrupt>
  4e:	00 00       	nop
  50:	40 c0       	rjmp	.+128    	; 0xd2 <__bad_interrupt>
  52:	00 00       	nop
  54:	3e c0       	rjmp	.+124    	; 0xd2 <__bad_interrupt>
  56:	00 00       	nop
  58:	3c c0       	rjmp	.+120    	; 0xd2 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	3a c0       	rjmp	.+116    	; 0xd2 <__bad_interrupt>
  5e:	00 00       	nop
  60:	38 c0       	rjmp	.+112    	; 0xd2 <__bad_interrupt>
  62:	00 00       	nop
  64:	36 c0       	rjmp	.+108    	; 0xd2 <__bad_interrupt>
  66:	00 00       	nop
  68:	34 c0       	rjmp	.+104    	; 0xd2 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	32 c0       	rjmp	.+100    	; 0xd2 <__bad_interrupt>
  6e:	00 00       	nop
  70:	30 c0       	rjmp	.+96     	; 0xd2 <__bad_interrupt>
  72:	00 00       	nop
  74:	2e c0       	rjmp	.+92     	; 0xd2 <__bad_interrupt>
  76:	00 00       	nop
  78:	2c c0       	rjmp	.+88     	; 0xd2 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	2a c0       	rjmp	.+84     	; 0xd2 <__bad_interrupt>
  7e:	00 00       	nop
  80:	28 c0       	rjmp	.+80     	; 0xd2 <__bad_interrupt>
  82:	00 00       	nop
  84:	26 c0       	rjmp	.+76     	; 0xd2 <__bad_interrupt>
  86:	00 00       	nop
  88:	24 c0       	rjmp	.+72     	; 0xd2 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	22 c0       	rjmp	.+68     	; 0xd2 <__bad_interrupt>
  8e:	00 00       	nop
  90:	20 c0       	rjmp	.+64     	; 0xd2 <__bad_interrupt>
  92:	00 00       	nop
  94:	1e c0       	rjmp	.+60     	; 0xd2 <__bad_interrupt>
	...

00000098 <__ctors_end>:
  98:	11 24       	eor	r1, r1
  9a:	1f be       	out	0x3f, r1	; 63
  9c:	cf ef       	ldi	r28, 0xFF	; 255
  9e:	d0 e2       	ldi	r29, 0x20	; 32
  a0:	de bf       	out	0x3e, r29	; 62
  a2:	cd bf       	out	0x3d, r28	; 61

000000a4 <__do_copy_data>:
  a4:	11 e0       	ldi	r17, 0x01	; 1
  a6:	a0 e0       	ldi	r26, 0x00	; 0
  a8:	b1 e0       	ldi	r27, 0x01	; 1
  aa:	ea eb       	ldi	r30, 0xBA	; 186
  ac:	f1 e0       	ldi	r31, 0x01	; 1
  ae:	00 e0       	ldi	r16, 0x00	; 0
  b0:	0b bf       	out	0x3b, r16	; 59
  b2:	02 c0       	rjmp	.+4      	; 0xb8 <__do_copy_data+0x14>
  b4:	07 90       	elpm	r0, Z+
  b6:	0d 92       	st	X+, r0
  b8:	a0 30       	cpi	r26, 0x00	; 0
  ba:	b1 07       	cpc	r27, r17
  bc:	d9 f7       	brne	.-10     	; 0xb4 <__do_copy_data+0x10>

000000be <__do_clear_bss>:
  be:	21 e0       	ldi	r18, 0x01	; 1
  c0:	a0 e0       	ldi	r26, 0x00	; 0
  c2:	b1 e0       	ldi	r27, 0x01	; 1
  c4:	01 c0       	rjmp	.+2      	; 0xc8 <.do_clear_bss_start>

000000c6 <.do_clear_bss_loop>:
  c6:	1d 92       	st	X+, r1

000000c8 <.do_clear_bss_start>:
  c8:	a0 30       	cpi	r26, 0x00	; 0
  ca:	b2 07       	cpc	r27, r18
  cc:	e1 f7       	brne	.-8      	; 0xc6 <.do_clear_bss_loop>
  ce:	71 d0       	rcall	.+226    	; 0x1b2 <main>
  d0:	72 c0       	rjmp	.+228    	; 0x1b6 <_exit>

000000d2 <__bad_interrupt>:
  d2:	96 cf       	rjmp	.-212    	; 0x0 <__vectors>

000000d4 <USB_init_general>:
Disable USB pad regulator
*/
#include "USB.h"

void USB_init_general(){
	USBCON |= (1<<USBE); //Enable USB. 0 - disable og reset
  d4:	e8 ed       	ldi	r30, 0xD8	; 216
  d6:	f0 e0       	ldi	r31, 0x00	; 0
  d8:	80 81       	ld	r24, Z
  da:	80 68       	ori	r24, 0x80	; 128
  dc:	80 83       	st	Z, r24
	
	//Må cleare detach før jeg går inn i host mode:
	clear_bit(UDCON,DETACH);
  de:	a0 ee       	ldi	r26, 0xE0	; 224
  e0:	b0 e0       	ldi	r27, 0x00	; 0
  e2:	8c 91       	ld	r24, X
  e4:	8e 7f       	andi	r24, 0xFE	; 254
  e6:	8c 93       	st	X, r24
	
	USBCON |= (1<<HOST); //Enable host mode
  e8:	80 81       	ld	r24, Z
  ea:	80 64       	ori	r24, 0x40	; 64
  ec:	80 83       	st	Z, r24
	clear_bit(USBCON, FRZCLK); //Unfreezer klokka.
  ee:	80 81       	ld	r24, Z
  f0:	8f 7d       	andi	r24, 0xDF	; 223
  f2:	80 83       	st	Z, r24
	USBCON |= (1<<OTGPADE); //Wnable OTG pad som egentlig er VBUS pad.
  f4:	80 81       	ld	r24, Z
  f6:	80 61       	ori	r24, 0x10	; 16
  f8:	80 83       	st	Z, r24
	USBCON |= (1<<IDTE); //ID transition interupt generation
  fa:	80 81       	ld	r24, Z
  fc:	82 60       	ori	r24, 0x02	; 2
  fe:	80 83       	st	Z, r24
	USBCON |= (1<<VBUSTE); //Vbus transition interupt generation
 100:	80 81       	ld	r24, Z
 102:	81 60       	ori	r24, 0x01	; 1
 104:	80 83       	st	Z, r24
	
	clear_bit(UHWCON,UIMOD);	//Host mode,
 106:	e7 ed       	ldi	r30, 0xD7	; 215
 108:	f0 e0       	ldi	r31, 0x00	; 0
 10a:	80 81       	ld	r24, Z
 10c:	8f 77       	andi	r24, 0x7F	; 127
 10e:	80 83       	st	Z, r24
	clear_bit(UHWCON,UIDE);		//bruke register for å bestemme mode, istedet for UID som ikke er koblet til noe
 110:	80 81       	ld	r24, Z
 112:	8f 7b       	andi	r24, 0xBF	; 191
 114:	80 83       	st	Z, r24
	set_bit(UHWCON, UVCONE);	//The Host must use the UVCON pin to drive an external power switch or regulator that powers the Vbus line. The UVCON pin is automatically asserted and set high by hardware when UVCONE and VBUSREQ bits are set by firmware
 116:	80 81       	ld	r24, Z
 118:	80 61       	ori	r24, 0x10	; 16
 11a:	80 83       	st	Z, r24
	set_bit(UHWCON, UVREGE);	//aktiverer pad regulator (trengs for å kjøre Usb)
 11c:	80 81       	ld	r24, Z
 11e:	81 60       	ori	r24, 0x01	; 1
 120:	80 83       	st	Z, r24
	//(USBSTA & VBUS) Staten til VBUS, brukes bare i device mode?
	
	//Interuptene vi kunne enable over:
	//(USBINT & IDTI) og (USBINT & VBUSTI) må cleares av software.
	
	OTGCON |= (1<<HNPREQ);	//1: aksepterer HNP
 122:	ed ed       	ldi	r30, 0xDD	; 221
 124:	f0 e0       	ldi	r31, 0x00	; 0
 126:	80 81       	ld	r24, Z
 128:	80 62       	ori	r24, 0x20	; 32
 12a:	80 83       	st	Z, r24
	OTGCON |= (1<<SRPSEL);	//1: VBUS pulsing as SRP method, 0: data line pulsing as SRP
 12c:	80 81       	ld	r24, Z
 12e:	88 60       	ori	r24, 0x08	; 8
 130:	80 83       	st	Z, r24
	OTGCON |= (1<<VBUSHWC); //Set to disable hardware controll over UVCON pin
 132:	80 81       	ld	r24, Z
 134:	84 60       	ori	r24, 0x04	; 4
 136:	80 83       	st	Z, r24
	
	//UVCON assert og deassert. Må gjøres av host
	//Asert og deassert fører til enable VBUS power supply generation??
	OTGCON |= (1<<VBUSREQ); //Cleares når neste kjøres (clear)
 138:	80 81       	ld	r24, Z
 13a:	82 60       	ori	r24, 0x02	; 2
 13c:	80 83       	st	Z, r24
	OTGCON |= (1<<VBUSRQC); //Cleares immediatly
 13e:	80 81       	ld	r24, Z
 140:	81 60       	ori	r24, 0x01	; 1
 142:	80 83       	st	Z, r24
 144:	08 95       	ret

00000146 <USB_init>:
}



void USB_init(){	
	USB_init_general();
 146:	c6 df       	rcall	.-116    	; 0xd4 <USB_init_general>
	
	//HC = Hardware cleared
	//Host stuff:
	//Må disable DETACH først
	
	UHCON |= (0<<RESUME);	//Sender resume signal. Kun ved SOFEN = 1. HC
 148:	ee e9       	ldi	r30, 0x9E	; 158
 14a:	f0 e0       	ldi	r31, 0x00	; 0
 14c:	80 81       	ld	r24, Z
 14e:	80 83       	st	Z, r24
	UHCON |= (0<<RESET);	//Sender USB reset signal. HC
 150:	80 81       	ld	r24, Z
 152:	80 83       	st	Z, r24
	UHCON |= (1<<SOFEN);	//Generer SOF på busen i fullspeed, keep-alive i low speed. 0-idle usb bus
 154:	80 81       	ld	r24, Z
 156:	81 60       	ori	r24, 0x01	; 1
 158:	80 83       	st	Z, r24
	
	//TOp 293 for interupts. Host wakeup, Host start of frame, upstream resume, downstream resume, usb reset sent, device disconnection, device connection
	 
	//USB host adress
	UHADDR = 0x99; //Hva skal vi velge?
 15a:	89 e9       	ldi	r24, 0x99	; 153
 15c:	80 93 a1 00 	sts	0x00A1, r24
	//Frame number: ligger i de 11 første bitene på UHFNUM, kan endres
	//UHFLEN data frame length transmited
	
	
	//Herfra pipe nr 0
	UPNUM |= 0b000; //Slect pipe number 0
 160:	e7 ea       	ldi	r30, 0xA7	; 167
 162:	f0 e0       	ldi	r31, 0x00	; 0
 164:	80 81       	ld	r24, Z
 166:	80 83       	st	Z, r24
	//uprst sende reset til en pipe, pipe 0 er bit 0, pipe 6 er bit 6
	
	UPCONX &= ~(1<<PFREEZE); //Clear to unfreez, Freezes ved feil. Kan også freeze ved å sette til 1
 168:	e9 ea       	ldi	r30, 0xA9	; 169
 16a:	f0 e0       	ldi	r31, 0x00	; 0
 16c:	80 81       	ld	r24, Z
 16e:	8f 7b       	andi	r24, 0xBF	; 191
 170:	80 83       	st	Z, r24
	
	UPCONX |= (1<<INMODE);	//Lar den sende infinite IN requests Om vi ikke har inf se UPINRQX
 172:	80 81       	ld	r24, Z
 174:	80 62       	ori	r24, 0x20	; 32
 176:	80 83       	st	Z, r24
	UPCONX |= (0<<RSTDT);	//Reset data toggle til init verdi. HC
 178:	80 81       	ld	r24, Z
 17a:	80 83       	st	Z, r24
	UPCONX |= (1<<PEN);		//Pipe enable
 17c:	80 81       	ld	r24, Z
 17e:	81 60       	ori	r24, 0x01	; 1
 180:	80 83       	st	Z, r24
	
	
	//Velger pipe type
	UPCFG0X |= (1<<PTYPE1)|(1<<PTYPE0); //Interrupt type pipe. Passer for keyboard mouse
 182:	ea ea       	ldi	r30, 0xAA	; 170
 184:	f0 e0       	ldi	r31, 0x00	; 0
 186:	80 81       	ld	r24, Z
 188:	80 6c       	ori	r24, 0xC0	; 192
 18a:	80 83       	st	Z, r24
	UPCFG0X |= (0<<PTOKEN1)|(1<<PTOKEN0); //01 IN, 10 OUT , 00 SETUP. Skal hvertfall ha IN til vanelig
 18c:	80 81       	ld	r24, Z
 18e:	80 61       	ori	r24, 0x10	; 16
 190:	80 83       	st	Z, r24
	UPCFG0X |= 0b001 << PEPNUM0; //Antall endpoints i pipen, skal settes according til pipe configuration
 192:	80 81       	ld	r24, Z
 194:	81 60       	ori	r24, 0x01	; 1
 196:	80 83       	st	Z, r24
	
	UPCFG1X |= (0b000 << PSIZE0); //Fra 000 til 101 gir pipe size 8 - 256 (2gang oppover)
 198:	eb ea       	ldi	r30, 0xAB	; 171
 19a:	f0 e0       	ldi	r31, 0x00	; 0
 19c:	80 81       	ld	r24, Z
 19e:	80 83       	st	Z, r24
	UPCFG1X |= (0<<PBK0); //0: 1bank, 1: 2 bank
 1a0:	80 81       	ld	r24, Z
 1a2:	80 83       	st	Z, r24
	
	UPCFG1X |= (1<<ALLOC); /*Set to configure the pipe memory with the characteristics.
 1a4:	80 81       	ld	r24, Z
 1a6:	82 60       	ori	r24, 0x02	; 2
 1a8:	80 83       	st	Z, r24
	Clear to update the memory allocation. Refer to the Memory Management chapter for more
	details	*/
	
	UPCFG2X = 0xFF; //MAx tid i ms for polling period for en interrupt pipe
 1aa:	8f ef       	ldi	r24, 0xFF	; 255
 1ac:	80 93 ad 00 	sts	0x00AD, r24
 1b0:	08 95       	ret

000001b2 <main>:

#include "MainInclude.h"
#include "Communication_drivers/USB.h"

int main(){
	USB_init();
 1b2:	c9 df       	rcall	.-110    	; 0x146 <USB_init>
 1b4:	ff cf       	rjmp	.-2      	; 0x1b4 <main+0x2>

000001b6 <_exit>:
 1b6:	f8 94       	cli

000001b8 <__stop_program>:
 1b8:	ff cf       	rjmp	.-2      	; 0x1b8 <__stop_program>
