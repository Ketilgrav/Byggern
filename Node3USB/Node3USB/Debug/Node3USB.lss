
Node3USB.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000002e2  00800100  0000042a  000004be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000042a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000005  008003e2  008003e2  000007a0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000007a0  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000a8  00000000  00000000  000007d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000cc7  00000000  00000000  00000878  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000035c  00000000  00000000  0000153f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000cea  00000000  00000000  0000189b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000010c  00000000  00000000  00002588  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000089a5  00000000  00000000  00002694  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000160  00000000  00000000  0000b039  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000078  00000000  00000000  0000b199  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0000353b  00000000  00000000  0000b211  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	4b c0       	rjmp	.+150    	; 0x98 <__ctors_end>
   2:	00 00       	nop
   4:	66 c0       	rjmp	.+204    	; 0xd2 <__bad_interrupt>
   6:	00 00       	nop
   8:	64 c0       	rjmp	.+200    	; 0xd2 <__bad_interrupt>
   a:	00 00       	nop
   c:	62 c0       	rjmp	.+196    	; 0xd2 <__bad_interrupt>
   e:	00 00       	nop
  10:	60 c0       	rjmp	.+192    	; 0xd2 <__bad_interrupt>
  12:	00 00       	nop
  14:	5e c0       	rjmp	.+188    	; 0xd2 <__bad_interrupt>
  16:	00 00       	nop
  18:	5c c0       	rjmp	.+184    	; 0xd2 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	5a c0       	rjmp	.+180    	; 0xd2 <__bad_interrupt>
  1e:	00 00       	nop
  20:	58 c0       	rjmp	.+176    	; 0xd2 <__bad_interrupt>
  22:	00 00       	nop
  24:	56 c0       	rjmp	.+172    	; 0xd2 <__bad_interrupt>
  26:	00 00       	nop
  28:	54 c0       	rjmp	.+168    	; 0xd2 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	52 c0       	rjmp	.+164    	; 0xd2 <__bad_interrupt>
  2e:	00 00       	nop
  30:	50 c0       	rjmp	.+160    	; 0xd2 <__bad_interrupt>
  32:	00 00       	nop
  34:	4e c0       	rjmp	.+156    	; 0xd2 <__bad_interrupt>
  36:	00 00       	nop
  38:	4c c0       	rjmp	.+152    	; 0xd2 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	4a c0       	rjmp	.+148    	; 0xd2 <__bad_interrupt>
  3e:	00 00       	nop
  40:	48 c0       	rjmp	.+144    	; 0xd2 <__bad_interrupt>
  42:	00 00       	nop
  44:	46 c0       	rjmp	.+140    	; 0xd2 <__bad_interrupt>
  46:	00 00       	nop
  48:	44 c0       	rjmp	.+136    	; 0xd2 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	42 c0       	rjmp	.+132    	; 0xd2 <__bad_interrupt>
  4e:	00 00       	nop
  50:	40 c0       	rjmp	.+128    	; 0xd2 <__bad_interrupt>
  52:	00 00       	nop
  54:	3e c0       	rjmp	.+124    	; 0xd2 <__bad_interrupt>
  56:	00 00       	nop
  58:	3c c0       	rjmp	.+120    	; 0xd2 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	3a c0       	rjmp	.+116    	; 0xd2 <__bad_interrupt>
  5e:	00 00       	nop
  60:	38 c0       	rjmp	.+112    	; 0xd2 <__bad_interrupt>
  62:	00 00       	nop
  64:	36 c0       	rjmp	.+108    	; 0xd2 <__bad_interrupt>
  66:	00 00       	nop
  68:	34 c0       	rjmp	.+104    	; 0xd2 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	32 c0       	rjmp	.+100    	; 0xd2 <__bad_interrupt>
  6e:	00 00       	nop
  70:	30 c0       	rjmp	.+96     	; 0xd2 <__bad_interrupt>
  72:	00 00       	nop
  74:	2e c0       	rjmp	.+92     	; 0xd2 <__bad_interrupt>
  76:	00 00       	nop
  78:	2c c0       	rjmp	.+88     	; 0xd2 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	2a c0       	rjmp	.+84     	; 0xd2 <__bad_interrupt>
  7e:	00 00       	nop
  80:	28 c0       	rjmp	.+80     	; 0xd2 <__bad_interrupt>
  82:	00 00       	nop
  84:	26 c0       	rjmp	.+76     	; 0xd2 <__bad_interrupt>
  86:	00 00       	nop
  88:	24 c0       	rjmp	.+72     	; 0xd2 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	22 c0       	rjmp	.+68     	; 0xd2 <__bad_interrupt>
  8e:	00 00       	nop
  90:	20 c0       	rjmp	.+64     	; 0xd2 <__bad_interrupt>
  92:	00 00       	nop
  94:	1e c0       	rjmp	.+60     	; 0xd2 <__bad_interrupt>
	...

00000098 <__ctors_end>:
  98:	11 24       	eor	r1, r1
  9a:	1f be       	out	0x3f, r1	; 63
  9c:	cf ef       	ldi	r28, 0xFF	; 255
  9e:	d0 e2       	ldi	r29, 0x20	; 32
  a0:	de bf       	out	0x3e, r29	; 62
  a2:	cd bf       	out	0x3d, r28	; 61

000000a4 <__do_copy_data>:
  a4:	13 e0       	ldi	r17, 0x03	; 3
  a6:	a0 e0       	ldi	r26, 0x00	; 0
  a8:	b1 e0       	ldi	r27, 0x01	; 1
  aa:	ea e2       	ldi	r30, 0x2A	; 42
  ac:	f4 e0       	ldi	r31, 0x04	; 4
  ae:	00 e0       	ldi	r16, 0x00	; 0
  b0:	0b bf       	out	0x3b, r16	; 59
  b2:	02 c0       	rjmp	.+4      	; 0xb8 <__do_copy_data+0x14>
  b4:	07 90       	elpm	r0, Z+
  b6:	0d 92       	st	X+, r0
  b8:	a2 3e       	cpi	r26, 0xE2	; 226
  ba:	b1 07       	cpc	r27, r17
  bc:	d9 f7       	brne	.-10     	; 0xb4 <__do_copy_data+0x10>

000000be <__do_clear_bss>:
  be:	23 e0       	ldi	r18, 0x03	; 3
  c0:	a2 ee       	ldi	r26, 0xE2	; 226
  c2:	b3 e0       	ldi	r27, 0x03	; 3
  c4:	01 c0       	rjmp	.+2      	; 0xc8 <.do_clear_bss_start>

000000c6 <.do_clear_bss_loop>:
  c6:	1d 92       	st	X+, r1

000000c8 <.do_clear_bss_start>:
  c8:	a7 3e       	cpi	r26, 0xE7	; 231
  ca:	b2 07       	cpc	r27, r18
  cc:	e1 f7       	brne	.-8      	; 0xc6 <.do_clear_bss_loop>
  ce:	77 d0       	rcall	.+238    	; 0x1be <main>
  d0:	aa c1       	rjmp	.+852    	; 0x426 <_exit>

000000d2 <__bad_interrupt>:
  d2:	96 cf       	rjmp	.-212    	; 0x0 <__vectors>

000000d4 <USB_init_general>:
Disable USB pad regulator
*/
#include "USB.h"

void USB_init_general(){
	USBCON |= (1<<USBE); //Enable USB. 0 - disable og reset
  d4:	e8 ed       	ldi	r30, 0xD8	; 216
  d6:	f0 e0       	ldi	r31, 0x00	; 0
  d8:	80 81       	ld	r24, Z
  da:	80 68       	ori	r24, 0x80	; 128
  dc:	80 83       	st	Z, r24
	
	//Må cleare detach før jeg går inn i host mode:
	clear_bit(UDCON,DETACH);
  de:	a0 ee       	ldi	r26, 0xE0	; 224
  e0:	b0 e0       	ldi	r27, 0x00	; 0
  e2:	8c 91       	ld	r24, X
  e4:	8e 7f       	andi	r24, 0xFE	; 254
  e6:	8c 93       	st	X, r24
	
	USBCON |= (1<<HOST); //Enable host mode
  e8:	80 81       	ld	r24, Z
  ea:	80 64       	ori	r24, 0x40	; 64
  ec:	80 83       	st	Z, r24
	clear_bit(USBCON, FRZCLK); //Unfreezer klokka.
  ee:	80 81       	ld	r24, Z
  f0:	8f 7d       	andi	r24, 0xDF	; 223
  f2:	80 83       	st	Z, r24
	USBCON |= (1<<OTGPADE); //Wnable OTG pad som egentlig er VBUS pad.
  f4:	80 81       	ld	r24, Z
  f6:	80 61       	ori	r24, 0x10	; 16
  f8:	80 83       	st	Z, r24
	USBCON |= (1<<IDTE); //ID transition interupt generation
  fa:	80 81       	ld	r24, Z
  fc:	82 60       	ori	r24, 0x02	; 2
  fe:	80 83       	st	Z, r24
	USBCON |= (1<<VBUSTE); //Vbus transition interupt generation
 100:	80 81       	ld	r24, Z
 102:	81 60       	ori	r24, 0x01	; 1
 104:	80 83       	st	Z, r24
	
	clear_bit(UHWCON,UIMOD);	//Host mode,
 106:	e7 ed       	ldi	r30, 0xD7	; 215
 108:	f0 e0       	ldi	r31, 0x00	; 0
 10a:	80 81       	ld	r24, Z
 10c:	8f 77       	andi	r24, 0x7F	; 127
 10e:	80 83       	st	Z, r24
	clear_bit(UHWCON,UIDE);		//bruke register for å bestemme mode, istedet for UID som ikke er koblet til noe
 110:	80 81       	ld	r24, Z
 112:	8f 7b       	andi	r24, 0xBF	; 191
 114:	80 83       	st	Z, r24
	set_bit(UHWCON, UVCONE);	//The Host must use the UVCON pin to drive an external power switch or regulator that powers the Vbus line. The UVCON pin is automatically asserted and set high by hardware when UVCONE and VBUSREQ bits are set by firmware
 116:	80 81       	ld	r24, Z
 118:	80 61       	ori	r24, 0x10	; 16
 11a:	80 83       	st	Z, r24
	set_bit(UHWCON, UVREGE);	//aktiverer pad regulator (trengs for å kjøre Usb)
 11c:	80 81       	ld	r24, Z
 11e:	81 60       	ori	r24, 0x01	; 1
 120:	80 83       	st	Z, r24
	//(USBSTA & VBUS) Staten til VBUS, brukes bare i device mode?
	
	//Interuptene vi kunne enable over:
	//(USBINT & IDTI) og (USBINT & VBUSTI) må cleares av software.
	
	OTGCON |= (1<<HNPREQ);	//1: aksepterer HNP
 122:	ed ed       	ldi	r30, 0xDD	; 221
 124:	f0 e0       	ldi	r31, 0x00	; 0
 126:	80 81       	ld	r24, Z
 128:	80 62       	ori	r24, 0x20	; 32
 12a:	80 83       	st	Z, r24
	clear_bit(OTGCON, SRPSEL);	//1: VBUS pulsing as SRP method, 0: data line pulsing as SRP. Kan ikke pulse VBUS, så slik.
 12c:	80 81       	ld	r24, Z
 12e:	87 7f       	andi	r24, 0xF7	; 247
 130:	80 83       	st	Z, r24
	OTGCON |= (1<<VBUSHWC); //Set to disable hardware controll over UVCON pin
 132:	80 81       	ld	r24, Z
 134:	84 60       	ori	r24, 0x04	; 4
 136:	80 83       	st	Z, r24
	
	//UVCON assert og deassert. Må gjøres av host
	//Asert og deassert fører til enable VBUS power supply generation??
	OTGCON |= (1<<VBUSREQ); //Cleares når neste kjøres (clear)
 138:	80 81       	ld	r24, Z
 13a:	82 60       	ori	r24, 0x02	; 2
 13c:	80 83       	st	Z, r24
	OTGCON |= (1<<VBUSRQC); //Cleares immediatly
 13e:	80 81       	ld	r24, Z
 140:	81 60       	ori	r24, 0x01	; 1
 142:	80 83       	st	Z, r24
	
	//Kan ha spesielle timer ting nederst side 259
	
	//OTGIEN: Interupt enable for: suspend Time-out, HNP error, Role exchange, BCERRE b connect error, vbus error, srp interrupt
	OTGIEN = 0xFF;
 144:	8f ef       	ldi	r24, 0xFF	; 255
 146:	80 93 de 00 	sts	0x00DE, r24
 14a:	08 95       	ret

0000014c <USB_init>:
}



void USB_init(){	
	USB_init_general();
 14c:	c3 df       	rcall	.-122    	; 0xd4 <USB_init_general>
	
	UHCON |= (1<<RESUME);	//Sender resume signal. Kun ved SOFEN = 1. HC
 14e:	ee e9       	ldi	r30, 0x9E	; 158
 150:	f0 e0       	ldi	r31, 0x00	; 0
 152:	80 81       	ld	r24, Z
 154:	84 60       	ori	r24, 0x04	; 4
 156:	80 83       	st	Z, r24
	UHCON |= (1<<RESET);	//Sender USB reset signal. HC
 158:	80 81       	ld	r24, Z
 15a:	82 60       	ori	r24, 0x02	; 2
 15c:	80 83       	st	Z, r24
	UHCON |= (1<<SOFEN);	//Generer SOF på busen i fullspeed, keep-alive i low speed. 0-idle usb bus
 15e:	80 81       	ld	r24, Z
 160:	81 60       	ori	r24, 0x01	; 1
 162:	80 83       	st	Z, r24
	
	
	//TOp 293 for interupts. Host wakeup, Host start of frame, upstream resume, downstream resume, usb reset sent, device disconnection, device connection
	UHIEN = 0xFF;
 164:	8f ef       	ldi	r24, 0xFF	; 255
 166:	80 93 a0 00 	sts	0x00A0, r24
	 
	//USB host adress
	UHADDR = 0x67; //Hva skal vi velge?
 16a:	97 e6       	ldi	r25, 0x67	; 103
 16c:	90 93 a1 00 	sts	0x00A1, r25
	UPCFG1X |= 0b011 << PSIZE0;
	UPCFG1X |= 0b00 << PBK0;*/
	
	
	//Pipe 1
	UPNUM = 0b001; //Slect pipe number 0
 170:	91 e0       	ldi	r25, 0x01	; 1
 172:	90 93 a7 00 	sts	0x00A7, r25
	//uprst sende reset til en pipe, pipe 0 er bit 0, pipe 6 er bit 6
	
	UPCONX &= ~(1<<PFREEZE); //Clear to unfreez, Freezes ved feil. Kan også freeze ved å sette til 1
 176:	e9 ea       	ldi	r30, 0xA9	; 169
 178:	f0 e0       	ldi	r31, 0x00	; 0
 17a:	90 81       	ld	r25, Z
 17c:	9f 7b       	andi	r25, 0xBF	; 191
 17e:	90 83       	st	Z, r25
	
	UPCONX |= (1<<INMODE);	//Lar den sende infinite IN requests Om vi ikke har inf se UPINRQX
 180:	90 81       	ld	r25, Z
 182:	90 62       	ori	r25, 0x20	; 32
 184:	90 83       	st	Z, r25
	UPCONX |= (0<<RSTDT);	//Reset data toggle til init verdi. HC
 186:	90 81       	ld	r25, Z
 188:	90 83       	st	Z, r25
	UPCONX |= (1<<PEN);		//Pipe enable
 18a:	90 81       	ld	r25, Z
 18c:	91 60       	ori	r25, 0x01	; 1
 18e:	90 83       	st	Z, r25
	
	
	//Velger pipe type
	UPCFG0X |= (1<<PTYPE1)|(1<<PTYPE0); //Interrupt type pipe. Passer for keyboard mouse
 190:	ea ea       	ldi	r30, 0xAA	; 170
 192:	f0 e0       	ldi	r31, 0x00	; 0
 194:	90 81       	ld	r25, Z
 196:	90 6c       	ori	r25, 0xC0	; 192
 198:	90 83       	st	Z, r25
	UPCFG0X |= (0<<PTOKEN1)|(1<<PTOKEN0); //01 IN, 10 OUT , 00 SETUP. Skal hvertfall ha IN til vanelig
 19a:	90 81       	ld	r25, Z
 19c:	90 61       	ori	r25, 0x10	; 16
 19e:	90 83       	st	Z, r25
	UPCFG0X |= 0b001 << PEPNUM0; //Antall endpoints i pipen, skal settes according til pipe configuration
 1a0:	90 81       	ld	r25, Z
 1a2:	91 60       	ori	r25, 0x01	; 1
 1a4:	90 83       	st	Z, r25
	
	UPCFG1X |= (0b000 << PSIZE0); //Fra 000 til 101 gir pipe size 8 - 256 (2gang oppover)
 1a6:	eb ea       	ldi	r30, 0xAB	; 171
 1a8:	f0 e0       	ldi	r31, 0x00	; 0
 1aa:	90 81       	ld	r25, Z
 1ac:	90 83       	st	Z, r25
	UPCFG1X |= (0<<PBK0); //0: 1bank, 1: 2 bank
 1ae:	90 81       	ld	r25, Z
 1b0:	90 83       	st	Z, r25
	
	UPCFG1X |= (1<<ALLOC); /*Set to configure the pipe memory with the characteristics.
 1b2:	90 81       	ld	r25, Z
 1b4:	92 60       	ori	r25, 0x02	; 2
 1b6:	90 83       	st	Z, r25
	Clear to update the memory allocation. Refer to the Memory Management chapter for more
	details	*/
	
	UPCFG2X = 0xFF; //MAx tid i ms for polling period for en interrupt pipe
 1b8:	80 93 ad 00 	sts	0x00AD, r24
 1bc:	08 95       	ret

000001be <main>:
#include "MainInclude.h"
#include "Communication_drivers/USB.h"
#include "TouchDrivers/oled.h"

int main(){
	USB_init();
 1be:	c6 df       	rcall	.-116    	; 0x14c <USB_init>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1c0:	2f ef       	ldi	r18, 0xFF	; 255
 1c2:	85 ea       	ldi	r24, 0xA5	; 165
 1c4:	9e e0       	ldi	r25, 0x0E	; 14
 1c6:	21 50       	subi	r18, 0x01	; 1
 1c8:	80 40       	sbci	r24, 0x00	; 0
 1ca:	90 40       	sbci	r25, 0x00	; 0
 1cc:	e1 f7       	brne	.-8      	; 0x1c6 <main+0x8>
 1ce:	00 c0       	rjmp	.+0      	; 0x1d0 <main+0x12>
 1d0:	00 00       	nop
	_delay_ms(300);
	
	oled_init();
 1d2:	09 d0       	rcall	.+18     	; 0x1e6 <oled_init>
	oled_home();
 1d4:	d0 d0       	rcall	.+416    	; 0x376 <oled_home>
	//oled_print("Touch test!");
	while(1){
		if(UHINT & DCONNI){
 1d6:	cf e9       	ldi	r28, 0x9F	; 159
 1d8:	d0 e0       	ldi	r29, 0x00	; 0
 1da:	88 81       	ld	r24, Y
			oled_print("1");
			oled_home();
		}
		else{
			oled_print("0");
 1dc:	8f ed       	ldi	r24, 0xDF	; 223
 1de:	93 e0       	ldi	r25, 0x03	; 3
 1e0:	07 d1       	rcall	.+526    	; 0x3f0 <oled_print>
			oled_home();
 1e2:	c9 d0       	rcall	.+402    	; 0x376 <oled_home>
 1e4:	fa cf       	rjmp	.-12     	; 0x1da <main+0x1c>

000001e6 <oled_init>:
	OLED_CMD[0] = row;
}

void oled_draw_line(void)
{
	OLED_DATA[0] = 0xFF;
 1e6:	e4 e7       	ldi	r30, 0x74	; 116
 1e8:	f0 e0       	ldi	r31, 0x00	; 0
 1ea:	80 81       	ld	r24, Z
 1ec:	8c 68       	ori	r24, 0x8C	; 140
 1ee:	80 83       	st	Z, r24
 1f0:	e5 e7       	ldi	r30, 0x75	; 117
 1f2:	f0 e0       	ldi	r31, 0x00	; 0
 1f4:	80 81       	ld	r24, Z
 1f6:	86 60       	ori	r24, 0x06	; 6
 1f8:	80 83       	st	Z, r24
 1fa:	8f ef       	ldi	r24, 0xFF	; 255
 1fc:	82 b9       	out	0x02, r24	; 2
 1fe:	88 b1       	in	r24, 0x08	; 8
 200:	83 60       	ori	r24, 0x03	; 3
 202:	88 b9       	out	0x08, r24	; 8
 204:	8f e9       	ldi	r24, 0x9F	; 159
 206:	9f e0       	ldi	r25, 0x0F	; 15
 208:	01 97       	sbiw	r24, 0x01	; 1
 20a:	f1 f7       	brne	.-4      	; 0x208 <oled_init+0x22>
 20c:	00 c0       	rjmp	.+0      	; 0x20e <oled_init+0x28>
 20e:	00 00       	nop
 210:	e0 91 02 01 	lds	r30, 0x0102
 214:	f0 91 03 01 	lds	r31, 0x0103
 218:	8e ea       	ldi	r24, 0xAE	; 174
 21a:	80 83       	st	Z, r24
 21c:	e0 91 02 01 	lds	r30, 0x0102
 220:	f0 91 03 01 	lds	r31, 0x0103
 224:	81 ea       	ldi	r24, 0xA1	; 161
 226:	80 83       	st	Z, r24
 228:	e0 91 02 01 	lds	r30, 0x0102
 22c:	f0 91 03 01 	lds	r31, 0x0103
 230:	8a ed       	ldi	r24, 0xDA	; 218
 232:	80 83       	st	Z, r24
 234:	e0 91 02 01 	lds	r30, 0x0102
 238:	f0 91 03 01 	lds	r31, 0x0103
 23c:	82 e1       	ldi	r24, 0x12	; 18
 23e:	80 83       	st	Z, r24
 240:	e0 91 02 01 	lds	r30, 0x0102
 244:	f0 91 03 01 	lds	r31, 0x0103
 248:	88 ec       	ldi	r24, 0xC8	; 200
 24a:	80 83       	st	Z, r24
 24c:	e0 91 02 01 	lds	r30, 0x0102
 250:	f0 91 03 01 	lds	r31, 0x0103
 254:	88 ea       	ldi	r24, 0xA8	; 168
 256:	80 83       	st	Z, r24
 258:	e0 91 02 01 	lds	r30, 0x0102
 25c:	f0 91 03 01 	lds	r31, 0x0103
 260:	8f e3       	ldi	r24, 0x3F	; 63
 262:	80 83       	st	Z, r24
 264:	e0 91 02 01 	lds	r30, 0x0102
 268:	f0 91 03 01 	lds	r31, 0x0103
 26c:	85 ed       	ldi	r24, 0xD5	; 213
 26e:	80 83       	st	Z, r24
 270:	e0 91 02 01 	lds	r30, 0x0102
 274:	f0 91 03 01 	lds	r31, 0x0103
 278:	80 e8       	ldi	r24, 0x80	; 128
 27a:	80 83       	st	Z, r24
 27c:	e0 91 02 01 	lds	r30, 0x0102
 280:	f0 91 03 01 	lds	r31, 0x0103
 284:	81 e8       	ldi	r24, 0x81	; 129
 286:	80 83       	st	Z, r24
 288:	e0 91 02 01 	lds	r30, 0x0102
 28c:	f0 91 03 01 	lds	r31, 0x0103
 290:	80 e5       	ldi	r24, 0x50	; 80
 292:	80 83       	st	Z, r24
 294:	e0 91 02 01 	lds	r30, 0x0102
 298:	f0 91 03 01 	lds	r31, 0x0103
 29c:	89 ed       	ldi	r24, 0xD9	; 217
 29e:	80 83       	st	Z, r24
 2a0:	e0 91 02 01 	lds	r30, 0x0102
 2a4:	f0 91 03 01 	lds	r31, 0x0103
 2a8:	81 e2       	ldi	r24, 0x21	; 33
 2aa:	80 83       	st	Z, r24
 2ac:	e0 91 02 01 	lds	r30, 0x0102
 2b0:	f0 91 03 01 	lds	r31, 0x0103
 2b4:	90 e2       	ldi	r25, 0x20	; 32
 2b6:	90 83       	st	Z, r25
 2b8:	e0 91 02 01 	lds	r30, 0x0102
 2bc:	f0 91 03 01 	lds	r31, 0x0103
 2c0:	10 82       	st	Z, r1
 2c2:	e0 91 02 01 	lds	r30, 0x0102
 2c6:	f0 91 03 01 	lds	r31, 0x0103
 2ca:	80 83       	st	Z, r24
 2cc:	e0 91 02 01 	lds	r30, 0x0102
 2d0:	f0 91 03 01 	lds	r31, 0x0103
 2d4:	10 82       	st	Z, r1
 2d6:	e0 91 02 01 	lds	r30, 0x0102
 2da:	f0 91 03 01 	lds	r31, 0x0103
 2de:	8f e7       	ldi	r24, 0x7F	; 127
 2e0:	80 83       	st	Z, r24
 2e2:	e0 91 02 01 	lds	r30, 0x0102
 2e6:	f0 91 03 01 	lds	r31, 0x0103
 2ea:	82 e2       	ldi	r24, 0x22	; 34
 2ec:	80 83       	st	Z, r24
 2ee:	e0 91 02 01 	lds	r30, 0x0102
 2f2:	f0 91 03 01 	lds	r31, 0x0103
 2f6:	10 82       	st	Z, r1
 2f8:	e0 91 02 01 	lds	r30, 0x0102
 2fc:	f0 91 03 01 	lds	r31, 0x0103
 300:	87 e0       	ldi	r24, 0x07	; 7
 302:	80 83       	st	Z, r24
 304:	e0 91 02 01 	lds	r30, 0x0102
 308:	f0 91 03 01 	lds	r31, 0x0103
 30c:	8b ed       	ldi	r24, 0xDB	; 219
 30e:	80 83       	st	Z, r24
 310:	e0 91 02 01 	lds	r30, 0x0102
 314:	f0 91 03 01 	lds	r31, 0x0103
 318:	80 e3       	ldi	r24, 0x30	; 48
 31a:	80 83       	st	Z, r24
 31c:	e0 91 02 01 	lds	r30, 0x0102
 320:	f0 91 03 01 	lds	r31, 0x0103
 324:	8d ea       	ldi	r24, 0xAD	; 173
 326:	80 83       	st	Z, r24
 328:	e0 91 02 01 	lds	r30, 0x0102
 32c:	f0 91 03 01 	lds	r31, 0x0103
 330:	10 82       	st	Z, r1
 332:	e0 91 02 01 	lds	r30, 0x0102
 336:	f0 91 03 01 	lds	r31, 0x0103
 33a:	84 ea       	ldi	r24, 0xA4	; 164
 33c:	80 83       	st	Z, r24
 33e:	e0 91 02 01 	lds	r30, 0x0102
 342:	f0 91 03 01 	lds	r31, 0x0103
 346:	86 ea       	ldi	r24, 0xA6	; 166
 348:	80 83       	st	Z, r24
 34a:	e0 91 02 01 	lds	r30, 0x0102
 34e:	f0 91 03 01 	lds	r31, 0x0103
 352:	8f ea       	ldi	r24, 0xAF	; 175
 354:	80 83       	st	Z, r24
 356:	98 e0       	ldi	r25, 0x08	; 8
 358:	20 e0       	ldi	r18, 0x00	; 0
 35a:	0a c0       	rjmp	.+20     	; 0x370 <oled_init+0x18a>
 35c:	e0 91 00 01 	lds	r30, 0x0100
 360:	f0 91 01 01 	lds	r31, 0x0101
 364:	10 82       	st	Z, r1
 366:	8f 5f       	subi	r24, 0xFF	; 255
 368:	80 38       	cpi	r24, 0x80	; 128
 36a:	c1 f7       	brne	.-16     	; 0x35c <oled_init+0x176>
 36c:	91 50       	subi	r25, 0x01	; 1
 36e:	11 f0       	breq	.+4      	; 0x374 <oled_init+0x18e>
 370:	82 2f       	mov	r24, r18
 372:	f4 cf       	rjmp	.-24     	; 0x35c <oled_init+0x176>
 374:	08 95       	ret

00000376 <oled_home>:
 376:	e0 91 02 01 	lds	r30, 0x0102
 37a:	f0 91 03 01 	lds	r31, 0x0103
 37e:	81 e2       	ldi	r24, 0x21	; 33
 380:	80 83       	st	Z, r24
 382:	e0 91 02 01 	lds	r30, 0x0102
 386:	f0 91 03 01 	lds	r31, 0x0103
 38a:	10 82       	st	Z, r1
 38c:	e0 91 02 01 	lds	r30, 0x0102
 390:	f0 91 03 01 	lds	r31, 0x0103
 394:	8f e7       	ldi	r24, 0x7F	; 127
 396:	80 83       	st	Z, r24
 398:	e0 91 02 01 	lds	r30, 0x0102
 39c:	f0 91 03 01 	lds	r31, 0x0103
 3a0:	82 e2       	ldi	r24, 0x22	; 34
 3a2:	80 83       	st	Z, r24
 3a4:	e0 91 02 01 	lds	r30, 0x0102
 3a8:	f0 91 03 01 	lds	r31, 0x0103
 3ac:	10 82       	st	Z, r1
 3ae:	e0 91 02 01 	lds	r30, 0x0102
 3b2:	f0 91 03 01 	lds	r31, 0x0103
 3b6:	87 e0       	ldi	r24, 0x07	; 7
 3b8:	80 83       	st	Z, r24
 3ba:	08 95       	ret

000003bc <oled_print_char>:
}

void oled_print_char(uint8_t* character)
{
	uint8_t i;
	OLED_DATA[0] = 0x00;
 3bc:	e0 91 00 01 	lds	r30, 0x0100
 3c0:	f0 91 01 01 	lds	r31, 0x0101
 3c4:	10 82       	st	Z, r1
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 3c6:	25 e3       	ldi	r18, 0x35	; 53
 3c8:	2a 95       	dec	r18
 3ca:	f1 f7       	brne	.-4      	; 0x3c8 <oled_print_char+0xc>
 3cc:	00 00       	nop
 3ce:	e8 2f       	mov	r30, r24
 3d0:	f9 2f       	mov	r31, r25
	_delay_us(10);
	for (i = 0; i < 5; i++)
 3d2:	80 e0       	ldi	r24, 0x00	; 0
	{
		OLED_DATA[0] = character[i];
 3d4:	a0 91 00 01 	lds	r26, 0x0100
 3d8:	b0 91 01 01 	lds	r27, 0x0101
 3dc:	91 91       	ld	r25, Z+
 3de:	9c 93       	st	X, r25
 3e0:	95 e0       	ldi	r25, 0x05	; 5
 3e2:	9a 95       	dec	r25
 3e4:	f1 f7       	brne	.-4      	; 0x3e2 <oled_print_char+0x26>
 3e6:	00 00       	nop
void oled_print_char(uint8_t* character)
{
	uint8_t i;
	OLED_DATA[0] = 0x00;
	_delay_us(10);
	for (i = 0; i < 5; i++)
 3e8:	8f 5f       	subi	r24, 0xFF	; 255
 3ea:	85 30       	cpi	r24, 0x05	; 5
 3ec:	99 f7       	brne	.-26     	; 0x3d4 <oled_print_char+0x18>
	{
		OLED_DATA[0] = character[i];
			_delay_us(1);
	}
}
 3ee:	08 95       	ret

000003f0 <oled_print>:
{
	OLED_DATA[0] = 0xFF;
}

void oled_print(char* data)
{
 3f0:	1f 93       	push	r17
 3f2:	cf 93       	push	r28
 3f4:	df 93       	push	r29
 3f6:	ec 01       	movw	r28, r24
	uint8_t i = 0;
	while(data[i] != 0)
 3f8:	e8 81       	ld	r30, Y
 3fa:	ee 23       	and	r30, r30
 3fc:	81 f0       	breq	.+32     	; 0x41e <oled_print+0x2e>
	OLED_DATA[0] = 0xFF;
}

void oled_print(char* data)
{
	uint8_t i = 0;
 3fe:	10 e0       	ldi	r17, 0x00	; 0
	while(data[i] != 0)
		oled_print_char(ascii[(uint8_t)data[i++]]);
 400:	1f 5f       	subi	r17, 0xFF	; 255
 402:	f0 e0       	ldi	r31, 0x00	; 0
 404:	ee 0f       	add	r30, r30
 406:	ff 1f       	adc	r31, r31
 408:	ec 5f       	subi	r30, 0xFC	; 252
 40a:	fe 4f       	sbci	r31, 0xFE	; 254
 40c:	80 81       	ld	r24, Z
 40e:	91 81       	ldd	r25, Z+1	; 0x01
 410:	d5 df       	rcall	.-86     	; 0x3bc <oled_print_char>
}

void oled_print(char* data)
{
	uint8_t i = 0;
	while(data[i] != 0)
 412:	fe 01       	movw	r30, r28
 414:	e1 0f       	add	r30, r17
 416:	f1 1d       	adc	r31, r1
 418:	e0 81       	ld	r30, Z
 41a:	e1 11       	cpse	r30, r1
 41c:	f1 cf       	rjmp	.-30     	; 0x400 <oled_print+0x10>
		oled_print_char(ascii[(uint8_t)data[i++]]);
}
 41e:	df 91       	pop	r29
 420:	cf 91       	pop	r28
 422:	1f 91       	pop	r17
 424:	08 95       	ret

00000426 <_exit>:
 426:	f8 94       	cli

00000428 <__stop_program>:
 428:	ff cf       	rjmp	.-2      	; 0x428 <__stop_program>
